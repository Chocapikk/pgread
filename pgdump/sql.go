package pgdump

import (
	"fmt"
	"io"
	"strings"
	"time"
)

// ToSQL writes the dump result as SQL statements to the writer.
// Generates CREATE TABLE and INSERT statements that can be imported into PostgreSQL.
func (r *DumpResult) ToSQL(w io.Writer) error {
	fmt.Fprintf(w, "-- PostgreSQL dump generated by pgread\n")
	fmt.Fprintf(w, "-- Generated at: %s\n\n", time.Now().Format(time.RFC3339))

	for _, db := range r.Databases {
		fmt.Fprintf(w, "-- Database: %s (OID: %d)\n", db.Name, db.OID)
		fmt.Fprintf(w, "-- \\connect %s\n\n", db.Name)

		if err := db.ToSQL(w); err != nil {
			return err
		}
	}
	return nil
}

// ToSQL writes a single database dump as SQL statements.
func (d *DatabaseDump) ToSQL(w io.Writer) error {
	for _, table := range d.Tables {
		if err := table.ToSQL(w); err != nil {
			return err
		}
		fmt.Fprintln(w)
	}
	return nil
}

// ToSQL writes a single table as CREATE TABLE and INSERT statements.
func (t *TableDump) ToSQL(w io.Writer) error {
	// CREATE TABLE
	fmt.Fprintf(w, "-- Table: %s (%d rows)\n", t.Name, t.RowCount)
	fmt.Fprintf(w, "CREATE TABLE IF NOT EXISTS %s (\n", quoteIdent(t.Name))

	for i, col := range t.Columns {
		sqlType := pgTypeToSQL(col.Type, col.TypID)
		fmt.Fprintf(w, "    %s %s", quoteIdent(col.Name), sqlType)
		if i < len(t.Columns)-1 {
			fmt.Fprint(w, ",")
		}
		fmt.Fprintln(w)
	}
	fmt.Fprintln(w, ");")
	fmt.Fprintln(w)

	// INSERT statements
	if len(t.Rows) == 0 {
		return nil
	}

	// Get column names in order
	colNames := make([]string, len(t.Columns))
	for i, col := range t.Columns {
		colNames[i] = quoteIdent(col.Name)
	}

	fmt.Fprintf(w, "INSERT INTO %s (%s) VALUES\n", quoteIdent(t.Name), strings.Join(colNames, ", "))

	for i, row := range t.Rows {
		values := make([]string, len(t.Columns))
		for j, col := range t.Columns {
			val, ok := row[col.Name]
			if !ok || val == nil {
				values[j] = "NULL"
			} else {
				values[j] = formatSQLValue(val, col.TypID)
			}
		}
		fmt.Fprintf(w, "    (%s)", strings.Join(values, ", "))
		if i < len(t.Rows)-1 {
			fmt.Fprintln(w, ",")
		} else {
			fmt.Fprintln(w, ";")
		}
	}

	return nil
}

// quoteIdent quotes a PostgreSQL identifier
func quoteIdent(name string) string {
	// Simple quoting - escape double quotes
	if strings.ContainsAny(name, " \t\n\"") || isReservedWord(name) {
		return "\"" + strings.ReplaceAll(name, "\"", "\"\"") + "\""
	}
	return name
}

// formatSQLValue formats a Go value as a SQL literal
func formatSQLValue(val interface{}, typID int) string {
	if val == nil {
		return "NULL"
	}

	switch v := val.(type) {
	case bool:
		if v {
			return "TRUE"
		}
		return "FALSE"

	case int, int16, int32, int64, uint32:
		return fmt.Sprintf("%d", v)

	case float32, float64:
		return fmt.Sprintf("%v", v)

	case string:
		return quoteLiteral(v)

	case []interface{}:
		// Array
		elements := make([]string, len(v))
		for i, elem := range v {
			elements[i] = formatSQLValue(elem, 0)
		}
		return "ARRAY[" + strings.Join(elements, ", ") + "]"

	case map[string]interface{}:
		// JSON/JSONB
		return quoteLiteral(mapToJSON(v))

	default:
		return quoteLiteral(fmt.Sprintf("%v", v))
	}
}

// quoteLiteral quotes a string for use as a SQL literal
func quoteLiteral(s string) string {
	// Use dollar quoting if string contains single quotes and backslashes
	if strings.Contains(s, "'") && strings.Contains(s, "\\") {
		// Find a unique tag
		tag := "$str$"
		for i := 0; strings.Contains(s, tag); i++ {
			tag = fmt.Sprintf("$str%d$", i)
		}
		return tag + s + tag
	}
	// Standard single quote escaping
	escaped := strings.ReplaceAll(s, "'", "''")
	return "'" + escaped + "'"
}

// mapToJSON converts a map to a JSON string
func mapToJSON(m map[string]interface{}) string {
	var sb strings.Builder
	sb.WriteByte('{')
	first := true
	for k, v := range m {
		if !first {
			sb.WriteByte(',')
		}
		first = false
		sb.WriteByte('"')
		sb.WriteString(strings.ReplaceAll(k, "\"", "\\\""))
		sb.WriteString("\":")
		writeJSONValue(&sb, v)
	}
	sb.WriteByte('}')
	return sb.String()
}

func writeJSONValue(sb *strings.Builder, v interface{}) {
	switch val := v.(type) {
	case nil:
		sb.WriteString("null")
	case bool:
		if val {
			sb.WriteString("true")
		} else {
			sb.WriteString("false")
		}
	case int, int16, int32, int64, uint32, float32, float64:
		fmt.Fprintf(sb, "%v", val)
	case string:
		sb.WriteByte('"')
		sb.WriteString(strings.ReplaceAll(strings.ReplaceAll(val, "\\", "\\\\"), "\"", "\\\""))
		sb.WriteByte('"')
	case map[string]interface{}:
		sb.WriteString(mapToJSON(val))
	case []interface{}:
		sb.WriteByte('[')
		for i, elem := range val {
			if i > 0 {
				sb.WriteByte(',')
			}
			writeJSONValue(sb, elem)
		}
		sb.WriteByte(']')
	default:
		fmt.Fprintf(sb, "\"%v\"", val)
	}
}

// pgTypeToSQL converts PostgreSQL type name to SQL type
func pgTypeToSQL(typeName string, typID int) string {
	switch typID {
	case OidBool:
		return "BOOLEAN"
	case OidInt2:
		return "SMALLINT"
	case OidInt4:
		return "INTEGER"
	case OidInt8:
		return "BIGINT"
	case OidFloat4:
		return "REAL"
	case OidFloat8:
		return "DOUBLE PRECISION"
	case OidNumeric:
		return "NUMERIC"
	case OidMoney:
		return "MONEY"
	case OidText:
		return "TEXT"
	case OidVarchar:
		return "VARCHAR"
	case OidBpchar, OidChar:
		return "CHAR"
	case OidBytea:
		return "BYTEA"
	case OidDate:
		return "DATE"
	case OidTime:
		return "TIME"
	case OidTimeTZ:
		return "TIME WITH TIME ZONE"
	case OidTimestamp:
		return "TIMESTAMP"
	case OidTimestampTZ:
		return "TIMESTAMP WITH TIME ZONE"
	case OidInterval:
		return "INTERVAL"
	case OidInet:
		return "INET"
	case OidCidr:
		return "CIDR"
	case OidMacaddr:
		return "MACADDR"
	case OidMacaddr8:
		return "MACADDR8"
	case OidUUID:
		return "UUID"
	case OidJSON:
		return "JSON"
	case OidJSONB:
		return "JSONB"
	case OidXML:
		return "XML"
	case OidPoint:
		return "POINT"
	case OidLine:
		return "LINE"
	case OidLseg:
		return "LSEG"
	case OidBox:
		return "BOX"
	case OidCircle:
		return "CIRCLE"
	case OidPath:
		return "PATH"
	case OidPolygon:
		return "POLYGON"
	case OidInt4Range:
		return "INT4RANGE"
	case OidInt8Range:
		return "INT8RANGE"
	case OidNumRange:
		return "NUMRANGE"
	case OidDateRange:
		return "DATERANGE"
	case OidTsRange:
		return "TSRANGE"
	case OidTsTzRange:
		return "TSTZRANGE"
	case OidBit:
		return "BIT"
	case OidVarbit:
		return "BIT VARYING"
	case OidTsvector:
		return "TSVECTOR"
	case OidTsquery:
		return "TSQUERY"
	default:
		// Fallback to type name or TEXT
		if typeName != "" && typeName != fmt.Sprintf("oid:%d", typID) {
			return strings.ToUpper(typeName)
		}
		return "TEXT"
	}
}

// isReservedWord checks if a word is a PostgreSQL reserved word
func isReservedWord(word string) bool {
	reserved := map[string]bool{
		"all": true, "analyse": true, "analyze": true, "and": true, "any": true,
		"array": true, "as": true, "asc": true, "asymmetric": true, "both": true,
		"case": true, "cast": true, "check": true, "collate": true, "column": true,
		"constraint": true, "create": true, "current_catalog": true, "current_date": true,
		"current_role": true, "current_time": true, "current_timestamp": true,
		"current_user": true, "default": true, "deferrable": true, "desc": true,
		"distinct": true, "do": true, "else": true, "end": true, "except": true,
		"false": true, "fetch": true, "for": true, "foreign": true, "from": true,
		"grant": true, "group": true, "having": true, "in": true, "initially": true,
		"intersect": true, "into": true, "lateral": true, "leading": true, "limit": true,
		"localtime": true, "localtimestamp": true, "not": true, "null": true, "offset": true,
		"on": true, "only": true, "or": true, "order": true, "placing": true, "primary": true,
		"references": true, "returning": true, "select": true, "session_user": true,
		"some": true, "symmetric": true, "table": true, "then": true, "to": true,
		"trailing": true, "true": true, "union": true, "unique": true, "user": true,
		"using": true, "variadic": true, "when": true, "where": true, "window": true, "with": true,
	}
	return reserved[strings.ToLower(word)]
}
